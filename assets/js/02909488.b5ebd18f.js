"use strict";(self.webpackChunkapache_streampark_website=self.webpackChunkapache_streampark_website||[]).push([[417],{21526:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>c,toc:()=>h});var a=t(86070),r=t(76113),i=t(60630),o=t(24990);const s={id:"dev-model",title:"Programming Paradigm",sidebar_position:1},l=void 0,c={id:"framework/dev-model",title:"Programming Paradigm",description:"There are some rules and conventions to be followed in any framework. Only by following and mastering these rules can we use them more easily and achieve twice the result with half the effort.When we develop Flink job, we actually use the API provided by Flink to write an executable program (which must have a main() function) according to the development method required by Flink. We access variousConnectorin the program, and after a series of operatoroperations, we finally sink the data to the target storage through the Connector .",source:"@site/docs/framework/1.model.md",sourceDirName:"framework",slug:"/framework/dev-model",permalink:"/docs/framework/dev-model",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/incubator-streampark-website/edit/dev/docs/framework/1.model.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"dev-model",title:"Programming Paradigm",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Version Upgrade Guide",permalink:"/docs/platform/version-upgrade"},next:{title:"Project Configuration",permalink:"/docs/framework/config"}},d={},h=[{value:"Architecture",id:"architecture",level:2},{value:"Programming paradigm",id:"programming-paradigm",level:2},{value:"DataStream",id:"datastream",level:3},{value:"Flink Sql",id:"flink-sql",level:3},{value:"TableEnvironment",id:"tableenvironment",level:4},{value:"StreamTableEnvironment",id:"streamtableenvironment",level:4},{value:"RunTime Context",id:"runtime-context",level:2},{value:"StreamingContext",id:"streamingcontext",level:3},{value:"TableContext",id:"tablecontext",level:3},{value:"StreamTableContext",id:"streamtablecontext",level:3},{value:"Life Cycle",id:"life-cycle",level:2},{value:"Life Cycle - init",id:"life-cycle---init",level:3},{value:"Life Cycle \u2014 config",id:"life-cycle--config",level:3},{value:"Life Cycle \u2014 ready",id:"life-cycle--ready",level:3},{value:"Life Cycle \u2014 handle",id:"life-cycle--handle",level:3},{value:"Life Cycle \u2014 start",id:"life-cycle--start",level:3},{value:"Life Cycle \u2014 destroy",id:"life-cycle--destroy",level:3},{value:"Catalog Structure",id:"catalog-structure",level:2},{value:"Packaged Deployment",id:"packaged-deployment",level:2},{value:"Start command",id:"start-command",level:2}];function m(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["There are some rules and conventions to be followed in any framework. Only by following and mastering these rules can we use them more easily and achieve twice the result with half the effort.When we develop Flink job, we actually use the API provided by Flink to write an executable program (which must have a ",(0,a.jsx)(n.code,{children:"main()"})," function) according to the development method required by Flink. We access various",(0,a.jsx)(n.code,{children:"Connector"}),"in the program, and after a series of ",(0,a.jsx)(n.code,{children:"operator"}),"operations, we finally sink the data to the target storage through the ",(0,a.jsx)(n.code,{children:"Connector"})," ."]}),"\n",(0,a.jsx)(n.p,{children:'We call this method of step-by-step programming according to certain agreed rules the "programming paradigm". In this chapter, we will talk about the "programming paradigm" of StreamPark and the development considerations.'}),"\n",(0,a.jsx)(n.p,{children:"Let's start from these aspects"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Architecture"}),"\n",(0,a.jsx)(n.li,{children:"Programming paradigm"}),"\n",(0,a.jsx)(n.li,{children:"RunTime Context"}),"\n",(0,a.jsx)(n.li,{children:"Life Cycle"}),"\n",(0,a.jsx)(n.li,{children:"Catalog Structure"}),"\n",(0,a.jsx)(n.li,{children:"Packaged Deployment"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(6119).A+"",width:"2734",height:"1311"})}),"\n",(0,a.jsx)(n.h2,{id:"programming-paradigm",children:"Programming paradigm"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"streampark-core"})," is positioned as a programming time framework, rapid development scaffolding, specifically created to simplify Flink development. Developers will use this module during the development phase. Let's take a look at what the programming paradigm of ",(0,a.jsx)(n.code,{children:"DataStream"})," and ",(0,a.jsx)(n.code,{children:"Flink Sql"})," with StreamPark looks like, and what the specifications and requirements are."]}),"\n",(0,a.jsx)(n.h3,{id:"datastream",children:"DataStream"}),"\n",(0,a.jsxs)(n.p,{children:["StreamPark provides both ",(0,a.jsx)(n.code,{children:"scala"})," and ",(0,a.jsx)(n.code,{children:"Java"})," APIs to develop ",(0,a.jsx)(n.code,{children:"DataStream"})," programs, the specific code development is as follows."]}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(o.A,{value:"scala",label:"Scala",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import org.apache.streampark.flink.core.scala.FlinkStreaming\nimport org.apache.flink.api.scala._\n\nobject MyFlinkApp extends FlinkStreaming {\n\n    override def handle(): Unit = {\n        ...\n    }\n}\n"})})}),(0,a.jsx)(o.A,{value:"Java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class MyFlinkJavaApp {\n\n    public static void main(String[] args) {\n        StreamEnvConfig JavaConfig = new StreamEnvConfig(args, (environment, parameterTool) -> {\n            //The user can set parameters for the environment...\n            System.out.println("environment argument set...");\n        });\n\n        StreamingContext context = new StreamingContext(JavaConfig);\n\n        ....\n\n        context.start();\n    }\n}\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["To develop with the ",(0,a.jsx)(n.code,{children:"scala"})," API, the program must inherit from ",(0,a.jsx)(n.code,{children:"FlinkStreaming"}),". After inheritance, it is mandatory for developers to implement the ",(0,a.jsx)(n.code,{children:"handle()"})," method, which is the entry point for users to write code, and the ",(0,a.jsx)(n.code,{children:"streamingContext"})," for developers to use."]}),"\n",(0,a.jsxs)(n.p,{children:["Development with the ",(0,a.jsx)(n.code,{children:"Java"})," API can not omit the ",(0,a.jsx)(n.code,{children:"main()"})," method due to the limitations of the language itself, so it will be a standard ",(0,a.jsx)(n.code,{children:"main()"})," function,. The user needs to create the ",(0,a.jsx)(n.code,{children:"StreamingContext"})," manually. ",(0,a.jsx)(n.code,{children:"StreamingContext"})," is a very important class, which will be introduced later."]}),"\n",(0,a.jsx)(n.admonition,{title:"tip",type:"tip",children:(0,a.jsxs)(n.p,{children:["The above lines of ",(0,a.jsx)(n.code,{children:"scala"})," and ",(0,a.jsx)(n.code,{children:"Java"})," code are the basic skeleton code necessary to develop ",(0,a.jsx)(n.code,{children:"DataStream"})," with StreamPark. Developing a ",(0,a.jsx)(n.code,{children:"DataStream"})," program with StreamPark. Starting from these lines of code, Java API development requires the developer to manually start the task ",(0,a.jsx)(n.code,{children:"start"}),"."]})}),"\n",(0,a.jsx)(n.h3,{id:"flink-sql",children:"Flink Sql"}),"\n",(0,a.jsx)(n.p,{children:"The TableEnvironment is used to create the contextual execution environment for Table & SQL programs and is the entry point for Table & SQL programs. The main functions of the TableEnvironment include: interfacing with external systems, registering and retrieving tables and metadata, executing SQL statements, and providing more detailed configuration options."}),"\n",(0,a.jsxs)(n.p,{children:["The Flink community has been promoting the batch processing capability of DataStream and unifying the stream-batch integration, and in Flink 1.12, the stream-batch integration is truly unified, many historical APIs such as: DataSet API, BatchTableEnvironment API, etc. are deprecated and retired from the history stage. TableEnvironment** and ",(0,a.jsx)(n.strong,{children:"StreamTableEnvironment"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["StreamPark provides a more convenient API for the development of ",(0,a.jsx)(n.strong,{children:"TableEnvironment"})," and ",(0,a.jsx)(n.strong,{children:"StreamTableEnvironment"})," environments."]}),"\n",(0,a.jsx)(n.h4,{id:"tableenvironment",children:"TableEnvironment"}),"\n",(0,a.jsx)(n.p,{children:"To develop Table & SQL jobs, TableEnvironment will be the recommended entry class for Flink, supporting both Java API and Scala API, the following code demonstrates how to develop a TableEnvironment type job in StreamPark"}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(o.A,{value:"scala",label:"Scala",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import org.apache.streampark.flink.core.scala.FlinkTable\n\nobject TableApp extends FlinkTable {\n\n    override def handle(): Unit = {\n    ...\n    }\n\n}\n"})})}),(0,a.jsx)(o.A,{value:"Java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'import org.apache.streampark.flink.core.scala.TableContext;\nimport org.apache.streampark.flink.core.scala.util.TableEnvConfig;\n\npublic class JavaTableApp {\n\n    public static void main(String[] args) {\n        TableEnvConfig tableEnvConfig = new TableEnvConfig(args, null);\n        TableContext context = new TableContext(tableEnvConfig);\n        ...\n        context.start("Flink SQl Job");\n    }\n}\n'})})})]}),"\n",(0,a.jsx)(n.admonition,{title:"tip",type:"tip",children:(0,a.jsxs)(n.p,{children:["The above lines of Scala and Java code are the essential skeleton code for developing a TableEnvironment with StreamPark.\nScala API must inherit FlinkTable, Java API development needs to manually construct TableContext, and the developer needs to manually start the task ",(0,a.jsx)(n.code,{children:"start"}),"."]})}),"\n",(0,a.jsx)(n.h4,{id:"streamtableenvironment",children:"StreamTableEnvironment"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"StreamTableEnvironment"})," is used in stream computing scenarios, where the object of stream computing is a ",(0,a.jsx)(n.code,{children:"DataStream"}),". Compared to ",(0,a.jsx)(n.code,{children:"TableEnvironment"}),", ",(0,a.jsx)(n.code,{children:"StreamTableEnvironment"})," provides an interface to convert between ",(0,a.jsx)(n.code,{children:"DataStream"})," and ",(0,a.jsx)(n.code,{children:"Table"}),". If your application is written using the ",(0,a.jsx)(n.code,{children:"DataStream API"})," in addition to the ",(0,a.jsx)(n.code,{children:"Table API"})," & ",(0,a.jsx)(n.code,{children:"SQL"}),", you need to use the ",(0,a.jsx)(n.code,{children:"StreamTableEnvironment"}),".\nThe following code demonstrates how to develop a ",(0,a.jsx)(n.code,{children:"StreamTableEnvironment"})," type job in StreamPark."]}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(o.A,{value:"scala",label:"Scala",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"package org.apache.streampark.test.tablesql\n\nimport org.apache.streampark.flink.core.scala.FlinkStreamTable\n\nobject StreamTableApp extends FlinkStreamTable {\n\n  override def handle(): Unit = {\n    ...\n  }\n\n}\n"})})}),(0,a.jsx)(o.A,{value:"Java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'\nimport org.apache.streampark.flink.core.scala.StreamTableContext;\nimport org.apache.streampark.flink.core.scala.util.StreamTableEnvConfig;\n\npublic class JavaStreamTableApp {\n\n    public static void main(String[] args) {\n        StreamTableEnvConfig JavaConfig = new StreamTableEnvConfig(args, null, null);\n        StreamTableContext context = new StreamTableContext(JavaConfig);\n\n        ...\n\n        context.start("Flink SQl Job");\n    }\n}\n'})})})]}),"\n",(0,a.jsx)(n.admonition,{title:"tip",type:"tip",children:(0,a.jsxs)(n.p,{children:["The above lines of scala and Java code are the essential skeleton code for developing ",(0,a.jsx)(n.code,{children:"StreamTableEnvironment"})," with StreamPark, and for developing ",(0,a.jsx)(n.code,{children:"StreamTableEnvironment"})," programs with StreamPark. Starting from these lines of code, Java code needs to construct ",(0,a.jsx)(n.code,{children:"StreamTableContext"})," manually, and ",(0,a.jsx)(n.code,{children:"Java API"})," development requires the developer to start the task ",(0,a.jsx)(n.code,{children:"start"})," manually."]})}),"\n",(0,a.jsx)(n.h2,{id:"runtime-context",children:"RunTime Context"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"RunTime Context"})," - ",(0,a.jsx)(n.strong,{children:"StreamingContext"})," , ",(0,a.jsx)(n.strong,{children:"TableContext"})," , ",(0,a.jsx)(n.strong,{children:"StreamTableContext"})," are three very important objects in StreamPark, next we look at the definition and role of these three ",(0,a.jsx)(n.strong,{children:"Context"}),"."]}),"\n",(0,a.jsx)("center",{children:(0,a.jsx)("img",{src:"/doc/image/streampark_coreapi.png",width:"60%"})}),"\n",(0,a.jsx)(n.h3,{id:"streamingcontext",children:"StreamingContext"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"StreamingContext"})," inherits from ",(0,a.jsx)(n.code,{children:"StreamExecutionEnvironment"}),", adding ",(0,a.jsx)(n.code,{children:"ParameterTool"})," on top of ",(0,a.jsx)(n.code,{children:"StreamExecutionEnvironment"}),", which can be simply understood as:"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"StreamingContext"})," = ",(0,a.jsx)(n.strong,{children:"ParameterTool"})," + ",(0,a.jsx)(n.strong,{children:"StreamExecutionEnvironment"})]}),"\n",(0,a.jsx)(n.p,{children:"The specific definitions are as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"class StreamingContext(val parameter: ParameterTool, private val environment: StreamExecutionEnvironment)\n    extends StreamExecutionEnvironment(environment.getJavaEnv) {\n\n  /**\n   * for scala\n   *\n   * @param args\n   */\n  def this(args: (ParameterTool, StreamExecutionEnvironment)) = this(args._1, args._2)\n\n  /**\n   * for Java\n   *\n   * @param args\n   */\n  def this(args: StreamEnvConfig) = this(FlinkStreamingInitializer.initJavaStream(args))\n\n  ...\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{title:"tip",type:"tip",children:(0,a.jsxs)(n.p,{children:["This object is very important and will be used throughout the lifecycle of the task in the ",(0,a.jsx)(n.code,{children:"DataStream"})," job. The ",(0,a.jsx)(n.code,{children:"StreamingContext"})," itself inherits from the ",(0,a.jsx)(n.code,{children:"StreamExecutionEnvironment"}),", and the configuration file is fully integrated into the ",(0,a.jsx)(n.code,{children:"StreamingContext"}),", so that it is very easy to get various parameters from the ",(0,a.jsx)(n.code,{children:"StreamingContext"}),"."]})}),"\n",(0,a.jsxs)(n.p,{children:["In StreamPark, ",(0,a.jsx)(n.code,{children:"StreamingContext"})," is also the entry class for the Java API to write ",(0,a.jsx)(n.code,{children:"DataStream"})," jobs, one of the constructors of ",(0,a.jsx)(n.code,{children:"StreamingContext"})," is specially built for the Java API, the constructor is defined as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"/**\n * for Java\n * @param args\n*/\ndef this(args: StreamEnvConfig) = this(FlinkStreamingInitializer.initJavaStream(args))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["From the above constructor you can see that to create ",(0,a.jsx)(n.code,{children:"StreamingContext"}),", you need to pass in a ",(0,a.jsx)(n.code,{children:"StreamEnvConfig"})," object. ",(0,a.jsx)(n.code,{children:"StreamEnvConfig"})," is defined as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"class StreamEnvConfig(val args: Array[String], val conf: StreamEnvConfigFunction)\n"})}),"\n",(0,a.jsx)(n.p,{children:"In the constructor of StreamEnvConfig,"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"args"})," is the start parameter and must be the ",(0,a.jsx)(n.code,{children:"args"})," in the ",(0,a.jsx)(n.code,{children:"main"})," method"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"conf"})," is a ",(0,a.jsx)(n.code,{children:"Function"})," of type ",(0,a.jsx)(n.code,{children:"StreamEnvConfigFunction"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The definition of ",(0,a.jsx)(n.code,{children:"StreamEnvConfigFunction"})," is as follows."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@FunctionalInterface\npublic interface StreamEnvConfigFunction {\n    /**\n     * Used to initialize the StreamExecutionEnvironment, for the function can be implemented, customize the parameters to be set...\n     *\n     * @param environment\n     * @param parameterTool\n     */\n    void configuration(StreamExecutionEnvironment environment, ParameterTool parameterTool);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The purpose of the ",(0,a.jsx)(n.code,{children:"Function"})," is to allow the developer to set more parameters by means of hooks, which will pass the ",(0,a.jsx)(n.code,{children:"parameter"})," (parsing all parameters in the configuration file) and the initialized ",(0,a.jsx)(n.code,{children:"StreamExecutionEnvironment"})," object to the developer to set more parameters, e.g.:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'StreamEnvConfig JavaConfig = new StreamEnvConfig(args, (environment, parameterTool) -> {\n    System.out.println("environment argument set...");\n    environment.getConfig().enableForceAvro();\n});\n\nStreamingContext context = new StreamingContext(JavaConfig);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"tablecontext",children:"TableContext"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"TableContext"})," inherits from ",(0,a.jsx)(n.code,{children:"TableEnvironment"}),". On top of ",(0,a.jsx)(n.code,{children:"TableEnvironment"}),", it adds ",(0,a.jsx)(n.code,{children:"ParameterTool"}),", which is used to create the contextual execution environment for ",(0,a.jsx)(n.code,{children:"Table"})," & ",(0,a.jsx)(n.code,{children:"SQL"})," programs. It can be simply understood as :"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"TableContext"})," = ",(0,a.jsx)(n.strong,{children:"ParameterTool"})," + ",(0,a.jsx)(n.strong,{children:"TableEnvironment"})]}),"\n",(0,a.jsx)(n.p,{children:"The specific definitions are as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"class TableContext(val parameter: ParameterTool,\n                   private val tableEnv: TableEnvironment)\n                   extends TableEnvironment\n                   with FlinkTableTrait {\n\n  /**\n   * for scala\n   *\n   * @param args\n   */\n  def this(args: (ParameterTool, TableEnvironment)) = this(args._1, args._2)\n\n  /**\n   * for Java\n   * @param args\n   */\n  def this(args: TableEnvConfig) = this(FlinkTableInitializer.initJavaTable(args))\n\n  ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In StreamPark, ",(0,a.jsx)(n.code,{children:"TableContext"})," is also the entry class for the Java API to write ",(0,a.jsx)(n.code,{children:"Table Sql"})," jobs of type ",(0,a.jsx)(n.code,{children:"TableEnvironment"}),". One of the constructor methods of ",(0,a.jsx)(n.code,{children:"TableContext"})," is a constructor specifically built for the ",(0,a.jsx)(n.code,{children:"Java API"}),", which is defined as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"\n/**\n* for Java\n* @param args\n*/\ndef this(args: TableEnvConfig) = this(FlinkTableInitializer.initJavaTable(args))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["From the above constructor you can see that to create a ",(0,a.jsx)(n.code,{children:"TableContext"}),", you need to pass in a ",(0,a.jsx)(n.code,{children:"TableEnvConfig"})," object. ",(0,a.jsx)(n.code,{children:"TableEnvConfig"})," is defined as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"class TableEnvConfig(val args: Array[String], val conf: TableEnvConfigFunction)\n"})}),"\n",(0,a.jsx)(n.p,{children:"In the constructor method of TableEnvConfig,"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"args"})," is the start parameter, and is the ",(0,a.jsx)(n.code,{children:"args"})," in the ",(0,a.jsx)(n.code,{children:"main"})," method."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"conf"})," is a ",(0,a.jsx)(n.code,{children:"Function"})," of type ",(0,a.jsx)(n.code,{children:"TableEnvConfigFunction"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The definition of ",(0,a.jsx)(n.code,{children:"TableEnvConfigFunction"})," is as follows."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@FunctionalInterface\npublic interface TableEnvConfigFunction {\n    /**\n     * Used to initialize the TableEnvironment, for the function can be implemented, customize the parameters to be set...\n     *\n     * @param tableConfig\n     * @param parameterTool\n     */\n    void configuration(TableConfig tableConfig, ParameterTool parameterTool);\n\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The purpose of the ",(0,a.jsx)(n.code,{children:"Function"})," is to allow the developer to set more parameters by hooking the ",(0,a.jsx)(n.code,{children:"parameter"})," (parsing all parameters in the configuration file) and the ",(0,a.jsx)(n.code,{children:"TableConfig"})," object in the initialized ",(0,a.jsx)(n.code,{children:"TableEnvironment"})," to the developer to set more parameters, such as:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'TableEnvConfig config = new TableEnvConfig(args,(tableConfig,parameterTool)->{\n    tableConfig.setLocalTimeZone(ZoneId.of("Asia/Shanghai"));\n});\nTableContext context = new TableContext(config);\n...\n'})}),"\n",(0,a.jsx)(n.h3,{id:"streamtablecontext",children:"StreamTableContext"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"StreamTableContext"})," inherits from ",(0,a.jsx)(n.code,{children:"StreamTableEnvironment"})," and is used in stream computing scenarios. The object of stream computation is ",(0,a.jsx)(n.code,{children:"DataStream"}),". Compared to ",(0,a.jsx)(n.code,{children:"TableEnvironment"}),", ",(0,a.jsx)(n.code,{children:"StreamTableEnvironment"})," provides an interface for conversion between ",(0,a.jsx)(n.code,{children:"DataStream"})," and ",(0,a.jsx)(n.code,{children:"Table"}),".\n",(0,a.jsx)(n.code,{children:"StreamTableContext"})," adds ",(0,a.jsx)(n.code,{children:"ParameterTool"})," on top of ",(0,a.jsx)(n.code,{children:"StreamTableEnvironment"})," and directly accesses the ",(0,a.jsx)(n.code,{children:"StreamTableEnvironment"})," API, which can be easily understood as:"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"StreamTableContext"})," = ",(0,a.jsx)(n.strong,{children:"ParameterTool"})," + ",(0,a.jsx)(n.strong,{children:"StreamTableEnvironment"})," + ",(0,a.jsx)(n.strong,{children:"StreamExecutionEnvironment"})]}),"\n",(0,a.jsx)(n.p,{children:"The specific definitions are as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"\nclass StreamTableContext(val parameter: ParameterTool,\n                         private val streamEnv: StreamExecutionEnvironment,\n                         private val tableEnv: StreamTableEnvironment)\n                         extends StreamTableEnvironment\n                         with FlinkTableTrait {\n\n  /**\n   * Once the Table is converted to a DataStream,\n   * The DataStream job must be executed using the execute method of the StreamExecutionEnvironment.\n   */\n  private[scala] var isConvertedToDataStream: Boolean = false\n\n  /**\n   * for scala\n   *\n   * @param args\n   */\n  def this(args: (ParameterTool, StreamExecutionEnvironment, StreamTableEnvironment)) =\n  this(args._1, args._2, args._3)\n\n  /**\n   * for Java\n   *\n   * @param args\n   */\n  def this(args: StreamTableEnvConfig) = this(FlinkTableInitializer.initJavaStreamTable(args))\n  ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In StreamPark, ",(0,a.jsx)(n.code,{children:"StreamTableContext"})," is the entry class for the Java API to write ",(0,a.jsx)(n.code,{children:"Table Sql"})," jobs of type ",(0,a.jsx)(n.code,{children:"StreamTableEnvironment"}),". One of the constructors of ",(0,a.jsx)(n.code,{children:"StreamTableContext"})," is a function built specifically for the Java API, which is defined as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"\n  /**\n   * for Java\n   *\n   * @param args\n   */\ndef this(args: StreamTableEnvConfig) = this(FlinkTableInitializer.initJavaStreamTable(args))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["From the above constructor you can see that to create ",(0,a.jsx)(n.code,{children:"StreamTableContext"}),", you need to pass in a ",(0,a.jsx)(n.code,{children:"StreamTableEnvConfig"})," object. ",(0,a.jsx)(n.code,{children:"StreamTableEnvConfig"})," is defined as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"class StreamTableEnvConfig (\n    val args: Array[String],\n    val streamConfig: StreamEnvConfigFunction,\n    val tableConfig: TableEnvConfigFunction\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:"The constructor of StreamTableEnvConfig has three parameters:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"args"})," is the start parameter, and must be ",(0,a.jsx)(n.code,{children:"args"})," in the ",(0,a.jsx)(n.code,{children:"main"})," method"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"streamConfig"})," is a ",(0,a.jsx)(n.code,{children:"Function"})," of type ",(0,a.jsx)(n.code,{children:"StreamEnvConfigFunction"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"tableConfig"})," is a ",(0,a.jsx)(n.code,{children:"Function"})," of type ",(0,a.jsx)(n.code,{children:"TableEnvConfigFunction"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The definitions of ",(0,a.jsx)(n.code,{children:"StreamEnvConfigFunction"})," and ",(0,a.jsx)(n.code,{children:"TableEnvConfigFunction"})," have been described above and will not be repeated here."]}),"\n",(0,a.jsxs)(n.p,{children:["The purpose of this ",(0,a.jsx)(n.code,{children:"Function"})," is to allow the developer to set more parameters by means of hooks. Unlike the other parameter settings above, this ",(0,a.jsx)(n.code,{children:"Function"})," provides the opportunity to set both the ",(0,a.jsx)(n.code,{children:"StreamExecutionEnvironment"})," and the ",(0,a.jsx)(n.code,{children:"TableEnvironment"}),", which will pass the ",(0,a.jsx)(n.code,{children:"parameter"})," and the initialized ",(0,a.jsx)(n.code,{children:"StreamExecutionEnvironment ' and the "}),"TableConfig",(0,a.jsx)(n.code,{children:"object in the"}),"TableEnvironment` are passed to the developer for additional parameter settings, such as:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'\nStreamTableEnvConfig JavaConfig = new StreamTableEnvConfig(args, (environment, parameterTool) -> {\n    environment.getConfig().enableForceAvro();\n}, (tableConfig, parameterTool) -> {\n    tableConfig.setLocalTimeZone(ZoneId.of("Asia/Shanghai"));\n});\n\nStreamTableContext context = new StreamTableContext(JavaConfig);\n\n...\n'})}),"\n",(0,a.jsxs)(n.admonition,{title:"tip",type:"info",children:[(0,a.jsxs)(n.p,{children:["You can use the ",(0,a.jsx)(n.code,{children:"StreamExecutionEnvironment"})," ",(0,a.jsx)(n.code,{children:"API"})," directly in the ",(0,a.jsx)(n.code,{children:"StreamTableContext"}),", ",(0,a.jsx)(n.strong,{children:"methods prefixed with $"})," are the ",(0,a.jsx)(n.code,{children:"StreamExecutionEnvironment"})," API."]}),(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(37255).A+"",width:"2024",height:"1378"})})]}),"\n",(0,a.jsx)(n.h2,{id:"life-cycle",children:"Life Cycle"}),"\n",(0,a.jsxs)(n.p,{children:["The lifecycle concept is currently only available for the ",(0,a.jsx)(n.code,{children:"scala"})," API. this lifecycle explicitly defines the entire process of running a task, which is executed according to this lifecycle as long as it is inherited from ",(0,a.jsx)(n.code,{children:"FlinkStreaming"})," or ",(0,a.jsx)(n.code,{children:"FlinkTable"})," or ",(0,a.jsx)(n.code,{children:"StreamingTable"}),". The core methods of the lifecycle are as follows."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"\n final def main(args: Array[String]): Unit = {\n    init(args)\n    ready()\n    handle()\n    jobExecutionResult = context.start()\n    destroy()\n  }\n\n  private[this] def init(args: Array[String]): Unit = {\n    SystemPropertyUtils.setAppHome(KEY_APP_HOME, classOf[FlinkStreaming])\n    context = new StreamingContext(FlinkStreamingInitializer.initStream(args, config))\n  }\n\n  /**\n   * Users can override the sub-method...\n   *\n   */\n  def ready(): Unit = {}\n\n  def config(env: StreamExecutionEnvironment, parameter: ParameterTool): Unit = {}\n\n  def handle(): Unit\n\n  def destroy(): Unit = {}\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"The life cycle is as follows."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"init"}),"          Stages of configuration file initialization"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"config"}),"        Stage of manual parameter setting by the developer"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ready"}),"         Stage for executing custom actions before starting"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"handle"}),"        Stages of developer code access"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"start"}),"         Stages of program initiation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"destroy"}),"       Stages of destruction"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Life Cycle",src:t(32621).A+"",width:"1790",height:"1560"})}),"\n",(0,a.jsx)(n.h3,{id:"life-cycle---init",children:"Life Cycle - init"}),"\n",(0,a.jsxs)(n.p,{children:["In the ",(0,a.jsx)(n.strong,{children:"init"})," phase, the framework automatically parses the incoming configuration file and initializes the ",(0,a.jsx)(n.code,{children:"StreamExecutionEnvironment"})," according to the various parameters defined inside. This step is automatically executed by the framework and does not require developer involvement."]}),"\n",(0,a.jsx)(n.h3,{id:"life-cycle--config",children:"Life Cycle \u2014 config"}),"\n",(0,a.jsxs)(n.p,{children:["The purpose of the ",(0,a.jsx)(n.strong,{children:"config"})," phase is to allow the developer to set more parameters (other than the agreed configuration file), by means of hooks. The ",(0,a.jsx)(n.strong,{children:"config"})," phase passes ",(0,a.jsx)(n.code,{children:"parameter"})," (all parameters in the configuration file parsed in the ",(0,a.jsx)(n.em,{children:"init"})," phase) and the ",(0,a.jsx)(n.code,{children:"StreamExecutionEnvironment"})," object initialized in the ",(0,a.jsx)(n.em,{children:"init"})," phase to the developer,this allows the developer to configure more parameters."]}),"\n",(0,a.jsx)(n.admonition,{title:"Description",type:"note",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"config"})," stage is an optional stage that requires developer participation."]})}),"\n",(0,a.jsx)(n.h3,{id:"life-cycle--ready",children:"Life Cycle \u2014 ready"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"ready"})," stage is an entry point for the developer to do other actions after the parameters have been set, and is done after **initialization is complete **before the ",(0,a.jsx)(n.strong,{children:"program is started"}),"."]}),"\n",(0,a.jsx)(n.admonition,{title:"Description",type:"note",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"ready"})," stage is a stage that requires developer participation and is optional."]})}),"\n",(0,a.jsx)(n.h3,{id:"life-cycle--handle",children:"Life Cycle \u2014 handle"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"handle"})," stage is the stage of accessing the code written by the developer, it is the entrance to the code written by the developer and is the most important stage, this ",(0,a.jsx)(n.code,{children:"handle"})," method will force the developer to implement."]}),"\n",(0,a.jsx)(n.admonition,{title:"Description",type:"note",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"handle"})," stage is a mandatory stage that requires developer participation."]})}),"\n",(0,a.jsx)(n.h3,{id:"life-cycle--start",children:"Life Cycle \u2014 start"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"start"})," phase, which starts the task, is executed automatically by the framework."]}),"\n",(0,a.jsx)(n.h3,{id:"life-cycle--destroy",children:"Life Cycle \u2014 destroy"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"destroy"})," phase is the last phase before jvm exits after the program has finished running, and is generally used to wrap up the work."]}),"\n",(0,a.jsx)(n.admonition,{title:"Description",type:"note",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"destroy"})," stage is an optional stage that requires developer participation."]})}),"\n",(0,a.jsx)(n.h2,{id:"catalog-structure",children:"Catalog Structure"}),"\n",(0,a.jsxs)(n.p,{children:["The recommended project directory structure is as follows, please refer to the directory structure and configuration in ",(0,a.jsx)(n.a,{href:"https://github.com/apache/incubator-streampark-quickstart",children:"StreamPark-flink-quickstart"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tree",children:".\n|\u2500\u2500 assembly\n\u2502    \u251c\u2500\u2500 bin\n\u2502    \u2502    \u251c\u2500\u2500 startup.sh                             //Launch Script\n\u2502    \u2502    \u251c\u2500\u2500 setclasspath.sh                        //ava environment variables related to the script (internal use of the framework, developers do not need to pay attention to)\n\u2502    \u2502    \u251c\u2500\u2500 shutdown.sh                            //Task stop script (not recommended)\n\u2502    \u2502    \u2514\u2500\u2500 flink.sh                               //the script that internal use to, when starting (this script is used internally in the framework, the developer does not need to pay attention to)\n\u2502    \u2502\u2500\u2500 conf\n\u2502    \u2502    \u251c\u2500\u2500 test\n\u2502    \u2502    \u2502    \u251c\u2500\u2500 application.yaml                  //Configuration file for the test phase\n\u2502    \u2502    \u2502    \u2514\u2500\u2500 sql.yaml                          //flink sql\n\u2502    \u2502    \u2502\n\u2502    \u2502    \u251c\u2500\u2500 prod\n\u2502    \u2502    \u2502    \u251c\u2500\u2500 application.yaml                  //Profiles for the production (prod) stage\n\u2502    \u2502    \u2502    \u2514\u2500\u2500 sql.yaml                          //flink sql\n\u2502    \u2502\u2500\u2500 logs                                        //logs Catalog\n\u2502    \u2514\u2500\u2500 temp\n\u2502\n\u2502\u2500\u2500 src\n\u2502    \u2514\u2500\u2500 main\n\u2502         \u251c\u2500\u2500 Java\n\u2502         \u251c\u2500\u2500 resources\n\u2502         \u2514\u2500\u2500 scala\n\u2502\n\u2502\u2500\u2500 assembly.xml\n\u2502\n\u2514\u2500\u2500 pom.xml\n"})}),"\n",(0,a.jsx)(n.p,{children:"assembly.xml is the configuration file needed for the assembly packaging plugin, defined as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"<assembly>\n    <id>bin</id>\n    <formats>\n        <format>tar.gz</format>\n    </formats>\n    <fileSets>\n        <fileSet>\n            <directory>assembly/bin</directory>\n            <outputDirectory>bin</outputDirectory>\n            <fileMode>0755</fileMode>\n        </fileSet>\n        <fileSet>\n            <directory>${project.build.directory}</directory>\n            <outputDirectory>lib</outputDirectory>\n            <fileMode>0755</fileMode>\n            <includes>\n                <include>*.jar</include>\n            </includes>\n            <excludes>\n                <exclude>original-*.jar</exclude>\n            </excludes>\n        </fileSet>\n        <fileSet>\n            <directory>assembly/conf</directory>\n            <outputDirectory>conf</outputDirectory>\n            <fileMode>0755</fileMode>\n        </fileSet>\n        <fileSet>\n            <directory>assembly/logs</directory>\n            <outputDirectory>logs</outputDirectory>\n            <fileMode>0755</fileMode>\n        </fileSet>\n        <fileSet>\n            <directory>assembly/temp</directory>\n            <outputDirectory>temp</outputDirectory>\n            <fileMode>0755</fileMode>\n        </fileSet>\n    </fileSets>\n</assembly>\n"})}),"\n",(0,a.jsx)(n.h2,{id:"packaged-deployment",children:"Packaged Deployment"}),"\n",(0,a.jsxs)(n.p,{children:["The recommended packaging mode in ",(0,a.jsx)(n.a,{href:"https://github.com/apache/incubator-streampark-quickstart/tree/dev/quickstart-flink",children:"streampark-flink-quickstart"})," is recommended. It runs ",(0,a.jsx)(n.code,{children:"maven package"})," directly to generate a standard StreamPark recommended project package, after unpacking the directory structure is as follows."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:".\nStreamPark-flink-quickstart-1.0.0\n\u251c\u2500\u2500 bin\n\u2502   \u251c\u2500\u2500 startup.sh                             //Launch Script\n\u2502   \u251c\u2500\u2500 setclasspath.sh                        //Java environment variable-related scripts (used internally, not of concern to users)\n\u2502   \u251c\u2500\u2500 shutdown.sh                            //Task stop script (not recommended)\n\u2502   \u251c\u2500\u2500 flink.sh                               //Scripts used internally at startup (used internally, not of concern to the user)\n\u251c\u2500\u2500 conf\n\u2502   \u251c\u2500\u2500 application.yaml                       //Project's configuration file\n\u2502   \u251c\u2500\u2500 sql.yaml                               // flink sql file\n\u251c\u2500\u2500 lib\n\u2502   \u2514\u2500\u2500 StreamPark-flink-quickstart-1.0.0.jar     //The project's jar package\n\u2514\u2500\u2500 temp\n"})}),"\n",(0,a.jsx)(n.h2,{id:"start-command",children:"Start command"}),"\n",(0,a.jsxs)(n.p,{children:["The application.yaml and sql.yaml configuration files need to be defined before starting. If the task to be started is a ",(0,a.jsx)(n.code,{children:"DataStream"})," task, just follow the configuration file directly after startup.sh."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"bin/startup.sh --conf conf/application.yaml\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If the task you want to start is the ",(0,a.jsx)(n.code,{children:"Flink Sql"})," task, you need to follow the configuration file and sql.yaml."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"bin/startup.sh --conf conf/application.yaml --sql conf/sql.yaml\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},24990:(e,n,t)=>{t.d(n,{A:()=>o});t(30758);var a=t(13526);const r={tabItem:"tabItem_Xevx"};var i=t(86070);function o(e){let{children:n,hidden:t,className:o}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,o),hidden:t,children:n})}},60630:(e,n,t)=>{t.d(n,{A:()=>S});var a=t(30758),r=t(13526),i=t(72469),o=t(25557),s=t(99688),l=t(17822),c=t(54991),d=t(52629);function h(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function m(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,c.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function u(e){let{queryString:n=!1,groupId:t}=e;const r=(0,o.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace({...r.location,search:n.toString()})}),[i,r])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=m(e),[o,l]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:i}))),[c,h]=u({queryString:t,groupId:r}),[f,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,i]=(0,d.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),x=(()=>{const e=c??f;return p({value:e,tabValues:i})?e:null})();(0,s.A)((()=>{x&&l(x)}),[x]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),h(e),g(e)}),[h,g,i]),tabValues:i}}var g=t(78820);const x={tabList:"tabList_wCRy",tabItem:"tabItem_v3ez"};var v=t(86070);function j(e){let{className:n,block:t,selectedValue:a,selectValue:o,tabValues:s}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),d=e=>{const n=e.currentTarget,t=l.indexOf(n),r=s[t].value;r!==a&&(c(n),o(r))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:s.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>l.push(e),onKeyDown:h,onClick:d,...i,className:(0,r.A)("tabs__item",x.tabItem,i?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function b(e){let{lazy:n,children:t,selectedValue:r}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function y(e){const n=f(e);return(0,v.jsxs)("div",{className:(0,r.A)("tabs-container",x.tabList),children:[(0,v.jsx)(j,{...n,...e}),(0,v.jsx)(b,{...n,...e})]})}function S(e){const n=(0,g.A)();return(0,v.jsx)(y,{...e,children:h(e.children)},String(n))}},37255:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/streampark_apis-574b985bc649f26aacf875ccd0155793.jpeg"},32621:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/streampark_scala_life_cycle-7bfdf4f1228b36f59fae79943d5c8108.png"},6119:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/streampark_archite-ff9eba80347b8b3c47d241007386f7bc.png"},76113:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(30758);const r={},i=a.createContext(r);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);