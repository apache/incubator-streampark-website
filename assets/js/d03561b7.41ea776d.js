"use strict";(self.webpackChunkapache_streampark_website=self.webpackChunkapache_streampark_website||[]).push([[7093],{5163:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>c,metadata:()=>l,toc:()=>u});var a=t(86070),r=t(76113),i=t(60630),s=t(24990);const c={id:"es",title:"Elasticsearch Connector",sidebar_position:5},o=void 0,l={id:"framework/connector/es",title:"Elasticsearch Connector",description:"Elasticsearch is a distributed, RESTful style search and data analysis",source:"@site/docs/framework/connector/5.es.md",sourceDirName:"framework/connector",slug:"/framework/connector/es",permalink:"/docs/framework/connector/es",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/incubator-streampark-website/edit/dev/docs/framework/connector/5.es.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"es",title:"Elasticsearch Connector",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Apache Doris Connector",permalink:"/docs/framework/connector/doris"},next:{title:"Apache HBase Connector",permalink:"/docs/framework/connector/hbase"}},d={},u=[{value:"Dependency of elastic writing",id:"dependency-of-elastic-writing",level:2},{value:"Write data to Elasticsearch based on the official",id:"write-data-to-elasticsearch-based-on-the-official",level:2},{value:"Using Apache StreamPark\u2122 writes to Elasticsearch",id:"using-apache-streampark-writes-to-elasticsearch",level:2},{value:"1. \u914d\u7f6e\u7b56\u7565\u548c\u8fde\u63a5\u4fe1\u606f",id:"1-\u914d\u7f6e\u7b56\u7565\u548c\u8fde\u63a5\u4fe1\u606f",level:3},{value:"2. \u5199\u5165Elasticsearch",id:"2-\u5199\u5165elasticsearch",level:3},{value:"Other configuration",id:"other-configuration",level:2},{value:"deal with failed Elasticsearch request",id:"deal-with-failed-elasticsearch-request",level:3},{value:"Configure the internal batch processor",id:"configure-the-internal-batch-processor",level:3},{value:"Apache StreamPark\u2122 configuration",id:"apache-streampark-configuration",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://www.elastic.co/cn/elasticsearch/",children:"Elasticsearch"})," is a distributed, RESTful style search and data analysis\nengine. ",(0,a.jsx)(n.a,{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/connectors/",children:"Apache Flink\xae officially"})," provides a connector for Elasticsearch, which is used to write data to Elasticsearch, which can provide ** at least once** Semantics."]}),"\n",(0,a.jsx)(n.p,{children:"ElasticsearchSink uses TransportClient (before 6.x) or RestHighLevelClient (starting with 6.x) to communicate with the Elasticsearch cluster. Apache StreamPark further encapsulates Flink-connector-elasticsearch6, shields development details, and simplifies write operations for Elasticsearch6 and above."}),"\n",(0,a.jsx)(n.admonition,{title:"hint",type:"tip",children:(0,a.jsx)(n.p,{children:"Because there are conflicts between different versions of Flink Connector Elasticsearch, StreamPark temporarily only\nsupports write operations of Elasticsearch6 and above. If you wants to using Elasticsearch5, you need to exclude the\nflink-connector-elasticsearch6 dependency and introduce the flink-connector-elasticsearch5 dependency to create\norg.apache.flink.streaming.connectors.elasticsearch5.ElasticsearchSink instance writes data."})}),"\n",(0,a.jsx)(n.h2,{id:"dependency-of-elastic-writing",children:"Dependency of elastic writing"}),"\n",(0,a.jsxs)(n.p,{children:["Different Elasticsearch versions rely on the Flink Connector Elasticsearch is not universal, the following information\ncomes from the ",(0,a.jsx)(n.a,{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/connectors/datastream/elasticsearch/",children:"flink-docs-release-1.14 document"}),":"]}),"\n",(0,a.jsx)(n.p,{children:"Elasticsearch 5.x Maven dependencies"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"\n<dependency>\n    <groupId>org.apache.flink</groupId>\n    <artifactId>flink-connector-elasticsearch5_2.11</artifactId>\n    <version>1.14.3</version>\n</dependency>\n"})}),"\n",(0,a.jsx)(n.p,{children:"Elasticsearch 6.x Maven dependencies"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"\n<dependency>\n    <groupId>org.apache.flink</groupId>\n    <artifactId>flink-connector-elasticsearch6_2.11</artifactId>\n    <version>1.14.3</version>\n</dependency>\n"})}),"\n",(0,a.jsx)(n.p,{children:"Elasticsearch 7.x ans above Maven dependencies"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"\n<dependency>\n    <groupId>org.apache.flink</groupId>\n    <artifactId>flink-connector-elasticsearch7_2.11</artifactId>\n    <version>1.14.3</version>\n</dependency>\n"})}),"\n",(0,a.jsx)(n.h2,{id:"write-data-to-elasticsearch-based-on-the-official",children:"Write data to Elasticsearch based on the official"}),"\n",(0,a.jsxs)(n.p,{children:["The following code is taken from the official documentation",(0,a.jsx)(n.a,{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/connectors/datastream/elasticsearch/#elasticsearch-sink",children:"Elasticsearch based on the official"})]}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(s.A,{value:"java, Elasticsearch 6.x ans above",java:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'import org.apache.flink.api.common.functions.RuntimeContext;\nimport org.apache.flink.streaming.api.datastream.DataStream;\nimport org.apache.flink.streaming.connectors.elasticsearch.ElasticsearchSinkFunction;\nimport org.apache.flink.streaming.connectors.elasticsearch.RequestIndexer;\nimport org.apache.flink.streaming.connectors.elasticsearch6.ElasticsearchSink;\n\nimport org.apache.http.HttpHost;\nimport org.elasticsearch.action.index.IndexRequest;\nimport org.elasticsearch.client.Requests;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nDataStream<String> input=...;\n\n        List<HttpHost> httpHosts=new ArrayList<>();\n        httpHosts.add(new HttpHost("127.0.0.1",9200,"http"));\n        httpHosts.add(new HttpHost("10.2.3.1",9200,"http"));\n\n// \u4f7f\u7528 ElasticsearchSink.Builder \u521b\u5efa ElasticsearchSink\n        ElasticsearchSink.Builder<String> esSinkBuilder=new ElasticsearchSink.Builder<>(\n        httpHosts,\n        new ElasticsearchSinkFunction<String>(){\npublic IndexRequest createIndexRequest(String element){\n        Map<String, String> json=new HashMap<>();\n        json.put("data",element);\n\n        return Requests.indexRequest()\n        .index("my-index")\n        .type("my-type")\n        .source(json);\n        }\n\n@Override\npublic void process(String element,RuntimeContext ctx,RequestIndexer indexer){\n        indexer.add(createIndexRequest(element));\n        }\n        }\n        );\n\n// Configuration for batch requests; the settings below cause the sink to commit immediately after receiving each element that would otherwise be cached\n        esSinkBuilder.setBulkFlushMaxActions(1);\n\nA RestClientFactory that provides custom configuration information for internally created REST clients\n        esSinkBuilder.setRestClientFactory(\n        restClientBuilder->{\n        restClientBuilder.setDefaultHeaders(...)\n        restClientBuilder.setMaxRetryTimeoutMillis(...)\n        restClientBuilder.setPathPrefix(...)\n        restClientBuilder.setHttpClientConfigCallback(...)\n        }\n        );\n\n// Finally, build and add the sink to the job pipeline\n        input.addSink(esSinkBuilder.build());\n'})})}),(0,a.jsx)(s.A,{value:"scala, Elasticsearch 6.x \u53ca\u4ee5\u4e0a",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'\nimport org.apache.flink.api.common.functions.RuntimeContext\nimport org.apache.flink.streaming.api.datastream.DataStream\nimport org.apache.flink.streaming.connectors.elasticsearch.ElasticsearchSinkFunction\nimport org.apache.flink.streaming.connectors.elasticsearch.RequestIndexer\nimport org.apache.flink.streaming.connectors.elasticsearch6.ElasticsearchSink\n\nimport org.apache.http.HttpHost\nimport org.elasticsearch.action.index.IndexRequest\nimport org.elasticsearch.client.Requests\n\nimport java.util.ArrayList\nimport java.util.List\n\nval input: DataStream[String] =\n...\n\nval httpHosts = new java.util.ArrayList[HttpHost]\nhttpHosts.add(new HttpHost("127.0.0.1", 9200, "http"))\nhttpHosts.add(new HttpHost("10.2.3.1", 9200, "http"))\n\nval esSinkBuilder = new ElasticsearchSink.Builder[String](\n  httpHosts,\n  new ElasticsearchSinkFunction[String] {\n    def process(element: String, ctx: RuntimeContext, indexer: RequestIndexer) {\n      val json = new java.util.HashMap[String, String]\n      json.put("data", element)\n\n      val rqst: IndexRequest = Requests.indexRequest\n        .index("my-index")\n        .`type`("my-type")\n        .source(json)\n\n      indexer.add(rqst)\n    }\n  }\n)\n\n// Configuration for batch requests; the settings below cause the sink to commit immediately after receiving each element that would otherwise be cached\nesSinkBuilder.setBulkFlushMaxActions(1)\n\n// A RestClientFactory that provides custom configuration information for internally created REST clients\nesSinkBuilder.setRestClientFactory(new RestClientFactory {\n  override def configureRestClientBuilder(restClientBuilder: RestClientBuilder): Unit = {\n    restClientBuilder.setDefaultHeaders(\n    ...)\n    restClientBuilder.setMaxRetryTimeoutMillis(\n    ...)\n    restClientBuilder.setPathPrefix(\n    ...)\n    restClientBuilder.setHttpClientConfigCallback(\n    ...)\n  }\n})\n\n// Finally, build and add the sink to the job pipeline\ninput.addSink(esSinkBuilder.build)\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["The ElasticsearchSink created above is very inflexible to add parameters. ",(0,a.jsx)(n.code,{children:"StreamPark"})," follows the concept of convention over configuration and automatic configuration.\nUsers only need to configure es connection parameters and Flink operating parameters, and StreamPark will automatically assemble source and sink,\nwhich greatly simplifies development logic and improves development efficiency and maintainability."]}),"\n",(0,a.jsx)(n.h2,{id:"using-apache-streampark-writes-to-elasticsearch",children:"Using Apache StreamPark\u2122 writes to Elasticsearch"}),"\n",(0,a.jsx)(n.p,{children:"Please ensure that operation requests are sent to the Elasticsearch cluster at least once after enabling Flink checkpointing in ESSink."}),"\n",(0,a.jsx)(n.h3,{id:"1-\u914d\u7f6e\u7b56\u7565\u548c\u8fde\u63a5\u4fe1\u606f",children:"1. \u914d\u7f6e\u7b56\u7565\u548c\u8fde\u63a5\u4fe1\u606f"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"#redis sink configure\n#  Required parameter, used by multiple nodes host1:port, host2:port,\nhost: localhost:9200\n#  optional parameters\n#  es:\n#    disableFlushOnCheckpoint: true #\u9ed8\u8ba4\u4e3afalse\n#    auth:\n#    user:\n#      password:\n#    rest:\n#      max.retry.timeout:\n#      path.prefix:\n#      content.type:\n#    connect:\n#      request.timeout:\n#      timeout:\n#    cluster.name: elasticsearch\n#  client.transport.sniff:\n#  bulk.flush.:\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-\u5199\u5165elasticsearch",children:"2. \u5199\u5165Elasticsearch"}),"\n",(0,a.jsx)(n.p,{children:"Using StreamPark writes to Elasticsearch"}),"\n",(0,a.jsx)(i.A,{children:(0,a.jsx)(s.A,{value:"scala",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import org.apache.streampark.flink.core.scala.FlinkStreaming\nimport org.apache.streampark.flink.core.scala.sink.ESSink\nimport org.apache.streampark.flink.core.scala.util.ElasticSearchUtils\nimport org.apache.flink.api.scala._\nimport org.elasticsearch.action.index.IndexRequest\nimport org.json4s.DefaultFormats\nimport org.json4s.jackson.Serialization\n\nimport java.util.Date\n\nobject ConnectorApp extends FlinkStreaming {\n\n\n  implicit lazy val formats: DefaultFormats.type = org.json4s.DefaultFormats\n\n  override def handle(): Unit = {\n    val ds = context.fromCollection(List(\n      OrderEntity(1, 1, 11.3d, 3.1d, new Date()),\n      OrderEntity(2, 1, 12.3d, 3.2d, new Date()),\n      OrderEntity(3, 1, 13.3d, 3.3d, new Date()),\n      OrderEntity(4, 1, 14.3d, 3.4d, new Date()),\n      OrderEntity(5, 1, 15.3d, 7.5d, new Date()),\n      OrderEntity(6, 1, 16.3d, 3.6d, new Date()),\n      OrderEntity(7, 1, 17.3d, 3.7d, new Date())\n    ))\n\n    // es sink.........\n\n    //1)Define the writing rules for Index\n    implicit def indexReq(x: OrderEntity): IndexRequest = ElasticSearchUtils.indexRequest(\n      "flink_order",\n      "_doc",\n      s"${x.id}_${x.time.getTime}",\n      Serialization.write(x)\n    )\n    //3)define esSink and sink = data. done\n    ESSink().sink6[OrderEntity](ds)\n  }\n\n\n  case class OrderEntity(id: Int, num: Int, price: Double, gmv: Double, time: Date) extends Serializable\n\n}\n'})})})}),"\n",(0,a.jsx)(n.p,{children:"Flink ElasticsearchSinkFunction\u53ef\u4ee5\u6267\u884c\u591a\u79cd\u7c7b\u578b\u8bf7\u6c42\uff0c\u5982\uff08DeleteRequest\u3001 UpdateRequest\u3001IndexRequest\uff09,StreamPark\u4e5f\u5bf9\u4ee5\u4e0a\u529f\u80fd\u8fdb\u884c\u4e86\u652f\u6301\uff0c\u5bf9\u5e94\u65b9\u6cd5\u5982\u4e0b\uff1a"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import org.apache.streampark.flink.core.scala.StreamingContext\nimport org.apache.flink.streaming.api.datastream.DataStreamSink\nimport org.apache.flink.streaming.api.scala.DataStream\nimport org.apache.flink.streaming.connectors.elasticsearch.ActionRequestFailureHandler\nimport org.apache.flink.streaming.connectors.elasticsearch.util.RetryRejectedExecutionFailureHandler\nimport org.apache.flink.streaming.connectors.elasticsearch6.RestClientFactory\nimport org.elasticsearch.action.delete.DeleteRequest\nimport org.elasticsearch.action.index.IndexRequest\nimport org.elasticsearch.action.update.UpdateRequest\n\nimport java.util.Properties\nimport scala.annotation.meta.param\n\n\nclass ESSink(@(transient@param) context: StreamingContext,\n             property: Properties = new Properties(),\n             parallelism: Int = 0,\n             name: String = null,\n             uid: String = null) {\n\n  /**\n   * for ElasticSearch6\n   *\n   * @param stream\n   * @param suffix\n   * @param restClientFactory\n   * @param failureHandler\n   * @param f\n   * @tparam T\n   * @return\n   */\n  def sink6[T](stream: DataStream[T],\n               suffix: String = "",\n               restClientFactory: RestClientFactory = null,\n               failureHandler: ActionRequestFailureHandler = new RetryRejectedExecutionFailureHandler)\n              (implicit f: T => IndexRequest): DataStreamSink[T] = {\n\n    new ES6Sink(context, property, parallelism, name, uid).sink[T](stream, suffix, restClientFactory, failureHandler, f)\n  }\n\n\n  def update6[T](stream: DataStream[T],\n                 suffix: String = "",\n                 restClientFactory: RestClientFactory = null,\n                 failureHandler: ActionRequestFailureHandler = new RetryRejectedExecutionFailureHandler)\n                (f: T => UpdateRequest): DataStreamSink[T] = {\n\n    new ES6Sink(context, property, parallelism, name, uid).sink[T](stream, suffix, restClientFactory, failureHandler, f)\n  }\n\n\n  def delete6[T](stream: DataStream[T],\n                 suffix: String = "",\n                 restClientFactory: RestClientFactory = null,\n                 failureHandler: ActionRequestFailureHandler = new RetryRejectedExecutionFailureHandler)\n                (f: T => DeleteRequest): DataStreamSink[T] = {\n\n    new ES6Sink(context, property, parallelism, name, uid).sink[T](stream, suffix, restClientFactory, failureHandler, f)\n  }\n\n}\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"When the Flink checkpoint is enabled, the Flink Elasticsearch Sink guarantees that operation requests are sent to the Elasticsearch cluster at least once.\nIt does this by waiting for all pending operation requests in the BulkProcessor while checkpointing.\nThis effectively guarantees that all requests will be successfully acknowledged by Elasticsearch before triggering the checkpoint and proceeding to process records sent to the sink.\nIf the user wants to disable flushing, they can configure disableFlushOnCheckpoint to true to do so,\nwhich essentially means that the sink will no longer provide any reliable delivery guarantees,\neven if checkpointing of the job topology is enabled."})}),"\n",(0,a.jsx)(n.h2,{id:"other-configuration",children:"Other configuration"}),"\n",(0,a.jsx)(n.h3,{id:"deal-with-failed-elasticsearch-request",children:"deal with failed Elasticsearch request"}),"\n",(0,a.jsxs)(n.p,{children:["An Elasticsearch operation request may fail for a variety of reasons. You can specify the failure handling logic by implementing ActionRequestFailureHandler.\nSee ",(0,a.jsx)(n.a,{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/connectors/datastream/elasticsearch/#elasticsearch-sink",children:"Official Documentation"})," - Handling Failed Elasticsearch Requests"]}),"\n",(0,a.jsx)(n.h3,{id:"configure-the-internal-batch-processor",children:"Configure the internal batch processor"}),"\n",(0,a.jsxs)(n.p,{children:["The BulkProcessor inside es can further configure its behavior of how to refresh the cache operation request,\nsee the ",(0,a.jsx)(n.a,{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/connectors/datastream/elasticsearch/#elasticsearch-sink",children:"official documentation"})," for details - ",(0,a.jsx)(n.strong,{children:"Configuring the Internal"})," Bulk Processor"]}),"\n",(0,a.jsx)(n.h3,{id:"apache-streampark-configuration",children:"Apache StreamPark\u2122 configuration"}),"\n",(0,a.jsxs)(n.p,{children:["All other configurations must comply with the StreamPark configuration.\nFor ",(0,a.jsx)(n.a,{href:"/docs/development/config",children:"specific configurable"})," items and the role of each parameter,\nplease refer to the project configuration"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},24990:(e,n,t)=>{t.d(n,{A:()=>s});t(30758);var a=t(13526);const r={tabItem:"tabItem_Xevx"};var i=t(86070);function s(e){let{children:n,hidden:t,className:s}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,s),hidden:t,children:n})}},60630:(e,n,t)=>{t.d(n,{A:()=>S});var a=t(30758),r=t(13526),i=t(72469),s=t(25557),c=t(99688),o=t(17822),l=t(54991),d=t(52629);function u(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,l.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:t}=e;const r=(0,s.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,o.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace({...r.location,search:n.toString()})}),[i,r])]}function m(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=h(e),[s,o]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:i}))),[l,u]=f({queryString:t,groupId:r}),[m,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,i]=(0,d.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),k=(()=>{const e=l??m;return p({value:e,tabValues:i})?e:null})();(0,c.A)((()=>{k&&o(k)}),[k]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),g(e)}),[u,g,i]),tabValues:i}}var g=t(78820);const k={tabList:"tabList_wCRy",tabItem:"tabItem_v3ez"};var x=t(86070);function v(e){let{className:n,block:t,selectedValue:a,selectValue:s,tabValues:c}=e;const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,i.a_)(),d=e=>{const n=e.currentTarget,t=o.indexOf(n),r=c[t].value;r!==a&&(l(n),s(r))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:c.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>o.push(e),onKeyDown:u,onClick:d,...i,className:(0,r.A)("tabs__item",k.tabItem,i?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function b(e){let{lazy:n,children:t,selectedValue:r}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function y(e){const n=m(e);return(0,x.jsxs)("div",{className:(0,r.A)("tabs-container",k.tabList),children:[(0,x.jsx)(v,{...n,...e}),(0,x.jsx)(b,{...n,...e})]})}function S(e){const n=(0,g.A)();return(0,x.jsx)(y,{...e,children:u(e.children)},String(n))}},76113:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var a=t(30758);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);